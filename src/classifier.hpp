#ifndef classifier_H
#define classifier_H
extern "C"{
	#include "yolo.h"
	#include "network.h"
	#include "parser.h"
	#include "image.h"
	#include "box.h"
	#include "data.h"
	#include "list.h"
	#include "layer.h"
	#include "utils.h"
}
#include "MaxRectsBinPack.h"
#include <cmath>
#include <algorithm>
#include <vector>
#include <string>

extern std::string rvoc_names[];
struct rRect{
	int org_x;
	int org_y;
	int packed_x;
	int packed_y;
	int width;
	int height;
	int merged;
	int labelID;
	float prob;
	std::string label;
	rRect(){};
	rRect(int x, int y, int w, int h, std::string l)
	{
		org_x = x;
		org_y = y;
		width = w;
		height = h;
		label = l;
		packed_x = 0;
		packed_y = 0;
		merged = -1;
		labelID = -1;
		prob = 0;
	}
	rRect(int x, int y, int w, int h, float p, std::string l)
	{
		org_x = x;
		org_y = y;
		width = w;
		height = h;
		label = l;
		packed_x = 0;
		packed_y = 0;
		merged = -1;
		labelID = -1;
		prob = p;
	}
};

class Classifier
{
public:
	//The input resolution of the CNN
	static const int w = 448;	
	static const int h = 448;
	static const int c = 3;
	//Variables concerning the Grid
	static const int nGridW = 28;	//Number of gird cells along the width
	static const int nGridH = 28;	//Number of grid cells along the height
	int grid[nGridW*nGridH];
	static const int gridSize = nGridW * nGridH;
	static const int gridW = w / nGridW;
	static const int gridH = h / nGridH;
	static const int maxNGridH = 2*nGridH/3;
	//Input Image dimensions
	int imW;
	int imH;
	// Other Variables
	std::vector<rRect> objectRects;	//The BB for objects read from the CSV Files *Currently-underwork
	std::vector<rRect> genObjectRects;	//The BB for objects generated by searching the grid
	int strippedHeight;	//The height of the image after packing the objects
	int searchID;	//The elements inside the grid which to be searched for
	int minNGrids;	//The minimum number of grid elements to produce an acceptable Rect
	float iThresh;	//Threshold for intersection between two rectangels
	Classifier();
	void FillGrid();	//Fills the grid with -2 for irrelevant areas and -1 for releavnt areas
	void ColorImageBlocks(image &im, std::vector<rRect> const& rects);	//Colors the blocks of objects in an image - For debugging purposes
	void GenerateRectsFromGrid();	//Scans the grid for rectangels, and assigns each one a number correspondig to object index in objects Vector
	bool GrowRectVertical(int startI, int objectID, int rectW, int rectH);	//Grows the found minimum Rect in the grid vertically
	bool GrowRectHorizontal(int startI, int objectID, int rectW, int rectH);	//Grows the found minimum Rect in the grid horizantally
	bool FindMinimumGridRect(int startI, int objectID);	//Finds the minimum sized rect inside the grid
	void PrintGrid();	//Prints the grid structure to console
	float CalculateAOI(int left1, int right1, int top1, int bottom1, int left2, int right2, int top2, int bottom2);	//Calculate the area of interesection between two rectangels
	void ModifyImage(image const& im, image &imPacked, std::vector<rRect> const& rects);	//Creates an image containg only the packed protions of the image
	int PackBins(std::vector<rRect> &rects);	//Applies the Bin packing algorithm in the detected objects and returns the height of the packed bin
	void AddRect(std::vector<rRect> &rects, int x, int y, int width, int height, std::string label);
	int ScanForRect(int x, int y, int width, int height);
	void PrintObjects();
	void PrintGenObjects();
	void TransformDimToCNN(std::vector<rRect> &rects);
	void TransformDimFromCNN(std::vector<rRect> &rects);
	void SetImageDim(int w, int h);
	void ProcessYOLOOut2ndRun(int n, ext_box *ext_boxes, bool clear);
	void ProcessYOLOOut1stRun(int n, ext_box *ext_boxes, float thresh);
	void ProcessYOLOOutExtBoxes(int n, ext_box *ext_boxes, float thresh);
	void MergeOverLappingRects();
	float CalculateMergerRatio(int left1, int right1, int top1, int bottom1, int left2, int right2, int top2, int bottom2);
	int CalculateIA(int left1, int right1, int top1, int bottom1, int left2, int right2, int top2, int bottom2);
};

#endif